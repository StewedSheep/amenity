defmodule Amenity.Trivia.GameServer do
  @moduledoc """
  GenServer that manages a single trivia game room's state and logic.
  """
  use GenServer
  require Logger

  alias Amenity.Trivia
  alias Amenity.Trivia.QuestionGenerator

  # Client API

  def start_link(room_id) do
    GenServer.start_link(__MODULE__, room_id, name: via_tuple(room_id))
  end

  def start_game(room_id, room_data, questions) do
    GenServer.call(via_tuple(room_id), {:start_game, room_data, questions})
  end

  def answer_question(room_id, user_id, answer_index, time_remaining) do
    GenServer.cast(via_tuple(room_id), {:answer_question, user_id, answer_index, time_remaining})
  end

  def get_state(room_id) do
    GenServer.call(via_tuple(room_id), :get_state)
  end

  def stop(room_id) do
    GenServer.stop(via_tuple(room_id))
  end

  defp via_tuple(room_id) do
    {:via, Registry, {Amenity.Trivia.GameRegistry, room_id}}
  end

  # Server Callbacks

  @impl true
  def init(room_id) do
    # Start a single timer process that will be used throughout the game
    {:ok, timer_pid} = Task.start_link(fn -> timer_loop() end)

    state = %{
      room_id: room_id,
      questions: [],
      current_question_index: 0,
      player_scores: %{},
      answered_users: MapSet.new(),
      timer_pid: timer_pid,
      timer_active: false,
      timer_value: 0,
      game_phase: :idle
    }

    {:ok, state}
  end

  # Single timer loop that runs for the entire game
  # Once started, it ticks every second until stopped
  defp timer_loop do
    receive do
      {:start, server_pid} ->
        # Start continuous ticking
        timer_loop_active(server_pid)

      :stop ->
        :ok
    end
  end

  defp timer_loop_active(server_pid) do
    receive do
      :stop ->
        :ok
    after
      1000 ->
        # Send tick every second
        send(server_pid, :timer_tick)
        # Continue ticking
        timer_loop_active(server_pid)
    end
  end

  @impl true
  def handle_call({:start_game, room_data, questions}, _from, state) do
    # Questions already generated by LiveView - just start the game
    # Initialize player scores
    player_scores = Map.new(room_data.participant_ids, fn id -> {id, 0} end)

    new_state = %{
      state
      | questions: questions,
        player_scores: player_scores,
        current_question_index: 0,
        timer_value: 3,
        game_phase: :countdown,
        timer_active: false
    }

    # Broadcast game started with initial countdown
    Phoenix.PubSub.broadcast(
      Amenity.PubSub,
      "trivia:room:#{state.room_id}",
      {:game_started, questions, 3}
    )

    # Start the SAME timer PID for countdown
    send(state.timer_pid, {:start, self()})

    {:reply, {:ok, questions}, %{new_state | timer_active: true}}
  end

  @impl true
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  @impl true
  def handle_cast({:answer_question, user_id, answer_index, time_remaining}, state) do
    current_question = Enum.at(state.questions, state.current_question_index)
    is_correct = answer_index == current_question["correct_answer"]

    # Calculate points
    points = if is_correct, do: calculate_points(time_remaining), else: 0

    # Update scores and answered users
    new_scores = Map.update(state.player_scores, user_id, points, &(&1 + points))
    new_answered = MapSet.put(state.answered_users, user_id)

    new_state = %{state | player_scores: new_scores, answered_users: new_answered}

    # Broadcast answer
    Phoenix.PubSub.broadcast(
      Amenity.PubSub,
      "trivia:room:#{state.room_id}",
      {:player_answered, user_id, points, new_scores}
    )

    # Check if everyone answered
    if MapSet.size(new_answered) >= map_size(state.player_scores) do
      send(self(), :next_question_or_end)
    end

    {:noreply, new_state}
  end

  @impl true
  def handle_info(:timer_tick, %{game_phase: :countdown, timer_active: true} = state) do
    new_value = state.timer_value - 1

    # Broadcast tick with current countdown value
    Phoenix.PubSub.broadcast(
      Amenity.PubSub,
      "trivia:room:#{state.room_id}",
      {:game_tick, :countdown, new_value}
    )

    if new_value > 0 do
      # Timer continues automatically
      {:noreply, %{state | timer_value: new_value}}
    else
      # Countdown finished, stop timer and move to first question
      send(state.timer_pid, :stop)
      send(self(), :show_question)
      {:noreply, %{state | timer_value: 0, timer_active: false, game_phase: :transitioning}}
    end
  end

  @impl true
  def handle_info(:show_question, state) do
    current_question = Enum.at(state.questions, state.current_question_index)

    # Reset for new question
    new_state = %{
      state
      | answered_users: MapSet.new(),
        timer_value: 10,
        game_phase: :question,
        timer_active: false
    }

    # Broadcast question with initial timer value
    Phoenix.PubSub.broadcast(
      Amenity.PubSub,
      "trivia:room:#{state.room_id}",
      {:show_question, current_question, state.current_question_index, 10, state.player_scores}
    )

    # Restart timer for question (it will tick continuously)
    send(state.timer_pid, {:start, self()})

    {:noreply, %{new_state | timer_active: true}}
  end

  @impl true
  def handle_info(:timer_tick, %{game_phase: :question, timer_active: true} = state) do
    new_value = state.timer_value - 1

    # Broadcast tick with current question timer value and scores
    Phoenix.PubSub.broadcast(
      Amenity.PubSub,
      "trivia:room:#{state.room_id}",
      {:game_tick, :question, new_value, state.player_scores}
    )

    if new_value > 0 do
      # Timer continues automatically
      {:noreply, %{state | timer_value: new_value}}
    else
      # Time's up, stop timer and move to next question
      send(state.timer_pid, :stop)
      send(self(), :next_question_or_end)
      {:noreply, %{state | timer_value: 0, timer_active: false, game_phase: :transitioning}}
    end
  end

  @impl true
  def handle_info(:timer_tick, state) do
    # Ignore timer ticks if not in a timed phase
    {:noreply, state}
  end

  @impl true
  def handle_info(:next_question_or_end, state) do
    next_index = state.current_question_index + 1

    if next_index < length(state.questions) do
      # More questions, show next one
      new_state = %{state | current_question_index: next_index, timer_active: false, game_phase: :transitioning}
      send(self(), :show_question)
      {:noreply, new_state}
    else
      # Game over - stop timer
      send(state.timer_pid, :stop)
      winners = calculate_winners(state.player_scores)

      Phoenix.PubSub.broadcast(
        Amenity.PubSub,
        "trivia:room:#{state.room_id}",
        {:game_over, winners, state.player_scores}
      )

      {:noreply, %{state | game_phase: :finished, timer_active: false}}
    end
  end

  # Helper Functions

  defp calculate_points(time_remaining) do
    max(10, min(100, 10 + trunc(time_remaining * 9)))
  end

  defp calculate_winners(player_scores) do
    max_score = player_scores |> Map.values() |> Enum.max(fn -> 0 end)

    player_scores
    |> Enum.filter(fn {_user_id, score} -> score == max_score end)
    |> Enum.map(fn {user_id, score} -> %{user_id: user_id, score: score} end)
  end
end
